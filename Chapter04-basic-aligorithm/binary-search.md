# Binary Search (二分搜索/二元搜尋)

## 定義

Binary Search 是一種高效的搜索演算法，用於在**已排序的陣列**中尋找特定元素。它的核心思想是「分而治之」（Divide and Conquer），每次將搜索範圍縮小一半。

## 核心概念

二分搜索的關鍵特點：
1. **前提條件**：陣列必須是已排序的
2. **策略**：每次比較中間元素，根據結果排除一半的搜索空間
3. **效率**：時間複雜度為 O(log n)，遠優於線性搜索的 O(n)

## 工作原理

### 步驟說明

1. **初始化**：設定兩個指標 `left` 和 `right`，分別指向陣列的起點和終點
2. **計算中點**：找到中間位置 `mid = Math.floor((left + right) / 2)`
3. **比較判斷**：
   - 如果 `arr[mid] === target`：找到了，返回 `mid`
   - 如果 `arr[mid] < target`：目標在右半部，更新 `left = mid + 1`
   - 如果 `arr[mid] > target`：目標在左半部，更新 `right = mid - 1`
4. **重複**：重複步驟 2-3，直到 `left > right`
5. **結束**：如果 `left > right` 還沒找到，返回 -1

### 視覺化範例

假設有一個已排序陣列：`[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]`，要搜尋目標值 `7`

```
步驟 1: [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
        left=0        mid=4       right=9
        比較: arr[4]=9 > 7 → 往左半部搜索

步驟 2: [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
        left=0  mid=1     right=3
        比較: arr[1]=3 < 7 → 往右半部搜索

步驟 3: [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
             left=2 mid=3 right=3
             比較: arr[3]=7 = 7 → 找到了！返回 index 3
```

## 時間複雜度

- **最佳情況 (Best Case)**: O(1)
  - 第一次就找到中間元素正好是目標值

- **平均情況 (Average Case)**: O(log n)
  - 需要進行 log₂(n) 次比較

- **最壞情況 (Worst Case)**: O(log n)
  - 目標值在邊緣或不存在，需要完整的 log₂(n) 次比較

### 為什麼是 O(log n)？

每次迭代都會將搜索範圍縮小一半：

| 迭代次數 | 剩餘元素數量 |
| -------- | ------------ |
| 0        | n            |
| 1        | n/2          |
| 2        | n/4          |
| 3        | n/8          |
| ...      | ...          |
| k        | n/2^k        |

當 `n/2^k = 1` 時停止，即 `2^k = n`，因此 `k = log₂(n)`

### 實際例子

| 陣列大小 (n) | 最多比較次數 log₂(n) | 說明                       |
| ------------ | -------------------- | -------------------------- |
| 10           | ~4                   | 2^4 = 16 ≥ 10              |
| 100          | ~7                   | 2^7 = 128 ≥ 100            |
| 1,000        | ~10                  | 2^10 = 1,024 ≥ 1,000       |
| 1,000,000    | ~20                  | 2^20 = 1,048,576 ≥ 1M      |
| 1,000,000,000| ~30                  | 2^30 = 1,073,741,824 ≥ 1B  |

💡 **驚人的效率**：即使在 10 億個元素中搜索，最多只需要 30 次比較！

## 空間複雜度

- **迭代版本**: O(1)
  - 只需要常數個變數（left, right, mid）

- **遞迴版本**: O(log n)
  - 遞迴調用棧的深度為 log₂(n)

## 優點

1. **效率極高**：時間複雜度 O(log n)，遠優於線性搜索
2. **可預測性**：性能穩定，最壞情況也是 O(log n)
3. **適合大數據**：數據量越大，優勢越明顯

## 缺點

1. **需要排序**：陣列必須事先排序，排序本身需要時間（通常 O(n log n)）
2. **僅適用陣列**：需要隨機存取能力，不適用於鏈結串列
3. **插入刪除麻煩**：維護已排序狀態需要額外成本

## 適用場景

✅ **適合使用二分搜索的情況**：
- 資料已經排序或可以排序
- 需要頻繁執行搜索操作
- 資料量大（數千、數萬甚至更多）
- 使用陣列等支援隨機存取的資料結構

❌ **不適合使用二分搜索的情況**：
- 資料未排序且排序成本高
- 資料量很小（線性搜索可能更簡單）
- 使用鏈結串列等不支援隨機存取的結構
- 資料頻繁變動（插入/刪除操作多）

## 實作技巧

### 1. 防止整數溢位

❌ **不好的寫法**（可能溢位）：
```typescript
const mid = Math.floor((left + right) / 2);
```

✅ **好的寫法**（避免溢位）：
```typescript
const mid = Math.floor(left + (right - left) / 2);
```

或者：
```typescript
const mid = Math.floor((left + right) >>> 1); // 無符號右移
```

### 2. 循環條件

使用 `while (left <= right)`，注意是 `<=` 不是 `<`

### 3. 邊界更新

- 往右搜索：`left = mid + 1`（不是 `left = mid`）
- 往左搜索：`right = mid - 1`（不是 `right = mid`）

## 變體與進階應用

### 1. 找到第一個出現的位置

在有重複元素的陣列中，找到目標值第一次出現的位置：
```typescript
// 找到後繼續往左找
if (arr[mid] === target) {
    result = mid;
    right = mid - 1; // 繼續在左半部尋找
}
```

### 2. 找到最後一個出現的位置

```typescript
// 找到後繼續往右找
if (arr[mid] === target) {
    result = mid;
    left = mid + 1; // 繼續在右半部尋找
}
```

### 3. 找到插入位置

找到目標值應該插入的位置（使陣列保持排序）

### 4. 找到最接近的值

找到陣列中最接近目標值的元素

## 與線性搜索的比較

| 特性         | Linear Search | Binary Search |
| ------------ | ------------- | ------------- |
| 時間複雜度   | O(n)          | O(log n)      |
| 空間複雜度   | O(1)          | O(1) 迭代版   |
| 是否需要排序 | 否            | 是            |
| 資料結構     | 任何          | 陣列          |
| 小資料集     | 適合          | 可能過度設計  |
| 大資料集     | 效率低        | 非常高效      |
| 實作難度     | 簡單          | 中等          |

### 效能對比

假設搜索 1,000,000 個元素：

- **Linear Search**：最壞情況需要 1,000,000 次比較
- **Binary Search**：最壞情況只需要 20 次比較

差距：**50,000 倍**！

## 常見錯誤

1. **忘記陣列必須已排序**
2. **無限循環**：邊界更新錯誤（例如 `left = mid` 而不是 `left = mid + 1`）
3. **整數溢位**：`left + right` 可能超出整數範圍
4. **循環條件錯誤**：使用 `<` 而不是 `<=`

## 練習題

1. 實作基本的二分搜索函數（迭代版本）
2. 實作遞迴版本的二分搜索
3. 在有重複元素的陣列中，找出目標值第一次和最後一次出現的位置
4. 實作「搜索旋轉排序陣列」（LeetCode 33）
5. 找到平方根的整數部分（不使用內建函數）

## 程式碼範例

請參考：
- [2-binary-search-practice.ts](2-binary-search-practice.ts) - 練習題
- [2-binary-search-demo.ts](2-binary-search-demo.ts) - 完整示範

## 總結

二分搜索是程式設計中最重要的演算法之一，它展示了「分而治之」策略的強大威力。掌握二分搜索不僅能解決搜索問題，還能培養將問題規模不斷減半的思維方式，這在許多演算法問題中都非常有用。

**記住**：當你面對一個已排序的陣列需要搜索時，第一個想到的應該是二分搜索！
