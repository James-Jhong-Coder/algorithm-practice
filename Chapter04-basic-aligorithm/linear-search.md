# Linear Search (線性搜尋/順序搜尋)

## 定義

Linear Search 是一種最基本的搜尋演算法，也稱為順序搜尋（Sequential Search）。它會從資料結構的第一個元素開始，逐一檢查每個元素，直到找到目標值或遍歷完所有元素為止。

## 工作原理

1. 從陣列的第一個元素開始
2. 將當前元素與目標值進行比較
3. 如果相等，返回當前索引位置
4. 如果不相等，移動到下一個元素
5. 重複步驟 2-4，直到找到目標或到達陣列末端
6. 如果遍歷完所有元素都沒找到，返回 -1 或 null

## 時間複雜度

- **最佳情況 (Best Case)**: O(1)
  - 目標元素在第一個位置

- **平均情況 (Average Case)**: O(n)
  - 目標元素在陣列中間某處
  - 需要檢查約 n/2 個元素
  - 註：雖然實際是 n/2 次，但 Big O 忽略常數係數，所以 O(n/2) = O(n)

- **最壞情況 (Worst Case)**: O(n)
  - 目標元素在最後一個位置或不存在
  - 需要檢查所有 n 個元素

## 空間複雜度

- **O(1)**: 只需要常數級別的額外空間來存儲索引和臨時變數

## Big O 符號說明

### 為什麼 O(n/2) = O(n)？

Big O 符號描述的是演算法的**增長率**，而不是精確的執行次數。因此會忽略以下內容：

1. **常數係數**: O(2n) = O(n/2) = O(100n) = O(n)
2. **低階項**: O(n² + n) = O(n²), O(n + 100) = O(n)

### 為什麼忽略常數？

當資料量很大時，常數的影響可以忽略不計：

| n         | n/2     | n         | 差異 |
| --------- | ------- | --------- | ---- |
| 10        | 5       | 10        | 2倍  |
| 1,000     | 500     | 1,000     | 2倍  |
| 1,000,000 | 500,000 | 1,000,000 | 2倍  |

雖然有2倍差異，但**增長趨勢相同**（都是線性），這才是 Big O 關注的重點。

### 常見的時間複雜度比較

從快到慢：
- O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2ⁿ) < O(n!)

## 優點

1. **簡單易懂**: 實作非常簡單，容易理解
2. **適用性廣**: 可用於任何資料結構（陣列、鏈結串列等）
3. **無需排序**: 不需要資料預先排序
4. **小資料集效率高**: 對於小型資料集，效能表現良好

## 缺點

1. **效率低**: 對於大型資料集，效能較差
2. **時間消耗**: 在最壞情況下需要檢查所有元素
3. **不適合大數據**: 當資料量很大時，其他搜尋算法（如二分搜尋）更有效率

## 適用場景

- 資料量較小的情況
- 資料未排序或無法排序
- 只需要搜尋一次或少數幾次
- 資料結構不支援隨機存取（如鏈結串列）

## 範例說明

假設有一個陣列：`[3, 7, 2, 9, 5, 1, 8]`，要搜尋目標值 `9`

```
步驟 1: 檢查 index 0 → 3 ≠ 9
步驟 2: 檢查 index 1 → 7 ≠ 9
步驟 3: 檢查 index 2 → 2 ≠ 9
步驟 4: 檢查 index 3 → 9 = 9 ✓ 找到！返回 index 3
```

## 實作範例

請參考 [1-linear-search.ts](1-linear-search.ts) 檔案查看完整的程式碼實作。

## 與其他搜尋算法比較

| 算法          | 時間複雜度 | 是否需要排序 | 適用場景         |
| ------------- | ---------- | ------------ | ---------------- |
| Linear Search | O(n)       | 否           | 小型或未排序資料 |
| Binary Search | O(log n)   | 是           | 大型已排序資料   |
| Hash Table    | O(1) 平均  | 否           | 頻繁查詢操作     |

## 練習題

1. 實作一個 linear search 函式，能夠找到陣列中所有符合條件的元素
2. 修改 linear search，使其能夠從後往前搜尋
3. 實作一個版本，能夠搜尋物件陣列中特定屬性的值

## 空間複雜度

- **O(1)**: 只需要常數級別的額外空間來存儲索引和臨時變數

## Big O 符號說明

### 為什麼 O(n/2) = O(n)？

Big O 符號描述的是演算法的**增長率**，而不是精確的執行次數。因此會忽略以下內容：

1. **常數係數**: O(2n) = O(n/2) = O(100n) = O(n)
2. **低階項**: O(n² + n) = O(n²), O(n + 100) = O(n)

### 為什麼忽略常數？

當資料量很大時，常數的影響可以忽略不計：

| n         | n/2     | n         | 差異 |
| --------- | ------- | --------- | ---- |
| 10        | 5       | 10        | 2倍  |
| 1,000     | 500     | 1,000     | 2倍  |
| 1,000,000 | 500,000 | 1,000,000 | 2倍  |

雖然有2倍差異，但**增長趨勢相同**（都是線性），這才是 Big O 關注的重點。

### 常見的時間複雜度比較

從快到慢：
- O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2ⁿ) < O(n!)